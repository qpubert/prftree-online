{"version":3,"sources":["index.js"],"names":["InputPane","undoDisabled","this","props","onUndo","redoDisabled","onRedo","inputPane","className","onClick","onViewClick","id","undefined","disabled","rootNode","sizes","minSize","expandToMin","gutterSize","gutterAlign","snapOffset","dragInterval","direction","cursor","value","errorMsg","readOnly","React","Component","OutputPane","outputSource","LiveEditor","currentLatexInputRef","createRef","state","history","createBlankNode","currentVersion","focusedInputId","focusWasPerformed","parentId","uuidv4","assumptions","labelInput","createBlankLatexInput","ruleNameInput","conclusionInput","lineType","lineDoubled","initialValue","currentNode","pred","ass","result","findNodeRec","candidateNode","currNode","findIndex","find","save","nodeId","func","event","rootNodeNewVersion","clone","setState","slice","concat","map","version","versionIndex","latexInputId","updateNodeStateOnEvent","newNodeVersion","findLatexInputRec","li","node","latexInput","smallTextModeEnabled","dots","focused","latexHidden","justFocused","stopPropagation","tabIndex","onFocus","_","hidden","display","tex","length","onError","updateLatexInputStateOnEvent","newLIVer","onSuccess","type","placeholder","defaultValue","style","width","Math","max","onInput","target","ref","onBlur","deepEqual","filter","index","current","focus","setSelectionRange","proofSummary","renderLatexInput","renderNode","newNodeVer","newAssumption","newParentVer","LINE_TYPES","indexOf","tablevel","tab","nodeSource","repeat","assumptionNode","generateNodeSource","focusedInput","console","log","ReactDOM","render","document","getElementById"],"mappings":"mRAUMA,G,8KAEF,IAAMC,GAAsC,IAAtBC,KAAKC,MAAMC,OAC3BC,GAAsC,IAAtBH,KAAKC,MAAMG,OAE3BC,EACJ,sBACEC,UAAU,kBACVC,QAASP,KAAKC,MAAMO,YAFtB,UAIE,sBAAKC,GAAG,kBAAR,UACE,wBACEF,QAASR,OAAeW,EAAYV,KAAKC,MAAMC,OAC/CS,SAAUZ,EAFZ,kBAIA,wBACEQ,QAASJ,OAAeO,EAAYV,KAAKC,MAAMG,OAC/CO,SAAUR,EAFZ,qBAKF,qBAAKG,UAAU,eAAf,SACGN,KAAKC,MAAMW,cAKlB,OACE,eAAC,IAAD,CACEN,UAAU,YACVO,MAAO,CAAC,GAAI,IACZC,QAAS,EACTC,aAAa,EACbC,WAAY,GACZC,YAAY,SACZC,WAAY,GACZC,aAAc,EACdC,UAAU,WACVC,OAAO,aAVT,UAYGhB,EACD,0BACEC,UAAU,0BACVgB,MAAOtB,KAAKC,MAAMsB,SAClBC,UAAQ,W,GA3CMC,IAAMC,YA0DxBC,E,uKAEF,OACE,0BACErB,UAAU,mBACVgB,MAAOtB,KAAKC,MAAM2B,aAClBJ,UAAQ,Q,GANSC,IAAMC,WAgBzBG,E,kDACJ,WAAY5B,GAAQ,IAAD,8BACjB,cAAMA,IACD6B,qBAAuBL,IAAMM,YAClC,EAAKC,MAAQ,CACXC,QAAS,CAAC,EAAKC,mBACfC,eAAgB,EAChBC,eAAgB,KAChBC,mBAAmB,GAPJ,E,4DAWHC,GACd,MAAO,CACLA,SAAUA,EACV7B,GAAI8B,cAEJC,YAAa,GACbC,WAAYzC,KAAK0C,wBACjBC,cAAe3C,KAAK0C,wBACpBE,gBAAiB5C,KAAK0C,wBAEtBG,SAAU,WACVC,aAAa,K,8CAIyB,IAApBC,EAAmB,uDAAJ,GACnC,MAAO,CACLtC,GAAI8B,cACJjB,MAAOyB,EACPxB,SAAU,M,kCAIFyB,EAAaC,GACvB,GAAIA,EAAKD,GACP,OAAOA,EACD,IAAD,gBACaA,EAAYR,aADzB,IACL,2BAA2C,CAAC,IAAjCU,EAAgC,QACnCC,EAASnD,KAAKoD,YAAYF,EAAKD,GACrC,QAAevC,IAAXyC,EACF,OAAOA,GAJN,iC,wCAUSvC,EAAUqC,GAC1B,IAAMI,EAAgBrD,KAAKoD,YAAYxC,GAAU,SAAC0C,GAChD,OAIuB,IAJhB,CACLA,EAASb,WACTa,EAASX,cACTW,EAASV,iBACTW,UAAUN,MAGd,QAAsBvC,IAAlB2C,EAGJ,MAAO,CACLA,EAAcZ,WACdY,EAAcV,cACdU,EAAcT,iBACdY,KAAKP,K,6CAGcQ,EAAMC,EAAQC,GAAO,IAAD,OACzC,OAAO,SAACC,GACN,IAAMC,EAAqBC,IAAM,EAAK9B,MAAMC,QAAQ,EAAKD,MAAMG,iBAE/DwB,EACE,EAAKP,YAAYS,GAAoB,SAAAP,GAAQ,OAAIA,EAAS7C,KAAOiD,KACjEE,GAEF,EAAKG,UAAS,SAAC/B,GAAD,MAAY,CACxBC,QAASwB,EACPzB,EAAMC,QAAQ+B,MAAM,EAAGhC,EAAMG,eAAiB,GAAG8B,OAAO,CAACJ,IACzD7B,EAAMC,QAAQiC,KAAI,SAACC,EAASC,GAC1B,OAAIA,IAAiBpC,EAAMG,eAClB0B,EAEAM,KAGbhC,eAAgBsB,EACdzB,EAAMG,eAAiB,EACvBH,EAAMG,sB,mDAMesB,EAAMC,EAAQW,EAAcV,GAAO,IAAD,OAC7D,OAAO3D,KAAKsE,uBAAuBb,EAAMC,GAAQ,SAACa,EAAgBX,GAChED,EAAK,EAAKa,kBAAkBD,GAAgB,SAAAE,GAAE,OAAIA,EAAGhE,KAAO4D,KAAeT,Q,uCAI9Dc,EAAMC,GAA0C,IAAD,OAA7BC,IAA6B,yDACxDC,EAA8B,SAC9BC,EAAU9E,KAAKgC,MAAMI,gBAAkBuC,EAAWlE,IAAMT,KAAKgC,MAAMI,eACnE2C,EAAcD,GAAmC,KAAxBH,EAAWpD,SACpCyD,EAAcF,IAAa9E,KAAKgC,MAAMK,kBAE5C,OACE,sBACE/B,UAAU,sBACVC,QAAS,SAACqD,GACRA,EAAMqB,mBAHV,UAME,qBACE3E,UAAU,qBACV4E,SAAU,EACVC,QAAS,SAACC,GACR,EAAKrB,SAAS,CACZ3B,eAAgBuC,EAAWlE,GAC3B4B,mBAAmB,KAGvBgD,OAAQN,EATV,SAWE,cAAC,IAAD,CACEO,SAAS,EACTC,IAAKX,EAAoB,yBACuB,IAA5BD,EAAWrD,MAAMkE,OAAeX,EAAOF,EAAWrD,MAD7C,gBAEQ,IAA5BqD,EAAWrD,MAAMkE,OAAeX,EAAOF,EAAWrD,OAEvDmE,QAASzF,KAAK0F,8BAA6B,EAAOhB,EAAKjE,GAAIkE,EAAWlE,IAAI,SAACkF,EAAUpE,GAEnFoE,EAASpE,SAAWA,KAEtBqE,UAAW5F,KAAK0F,8BAA6B,EAAOhB,EAAKjE,GAAIkE,EAAWlE,IAAI,SAACkF,EAAUP,GACrFO,EAASpE,SAAW,UAIzBwD,GAAe,qBAAKzE,UAAU,oBAAf,SACd,uBACEA,UAAmC,KAAxBqE,EAAWpD,SAAkB,GAAK,sBAC7CsE,KAAK,OACLC,YAAajB,EACbkB,aAAcpB,EAAWrD,MACzB0E,MAAO,CAAEC,MAAM,GAAD,OAAKC,KAAKC,IAAItB,EAAKW,OAAQb,EAAWrD,MAAMkE,QAA5C,OACdY,QAASpG,KAAK0F,8BAA6B,EAAOhB,EAAKjE,GAAIkE,EAAWlE,IAAI,SAACkF,EAAU/B,GACnF+B,EAASrE,MAAQsC,EAAMyC,OAAO/E,SAEhCgF,IAAKxB,EAAU9E,KAAK8B,qBAAuB,KAC3CqD,QAASnF,KAAK0F,6BAA6BV,EAAaN,EAAKjE,GAAIkE,EAAWlE,IAAI,SAACkF,EAAU/B,GACzF,EAAKG,SAAS,CACZ3B,eAAgBuC,EAAWlE,QAG/B8F,OAAQ,SAAC3C,GACH4C,IACF,EAAKxE,MAAMC,QAAQ,EAAKD,MAAMG,gBAC9B,EAAKH,MAAMC,QAAQ,EAAKD,MAAMG,eAAiB,KAE/C,EAAK4B,UAAS,SAAC/B,GAAD,MAAY,CACxBC,QAASD,EAAMC,QAAQwE,QAAO,SAACrB,EAAGsB,GAAJ,OAAeA,IAAU1E,EAAMG,kBAC7DA,eAAgBH,EAAMG,eAAiB,gB,2CAWjDnC,KAAK8B,qBAAqB6E,UAAY3G,KAAKgC,MAAMK,oBACnDrC,KAAK8B,qBAAqB6E,QAAQC,QAClC5G,KAAK8B,qBAAqB6E,QAAQE,kBAAkB,EAAG7G,KAAK8B,qBAAqB6E,QAAQrF,MAAMkE,QAC/FxF,KAAK+D,SAAS,CACZ1B,mBAAmB,O,iCAKdqC,GAAO,IAAD,OACToC,EAAepC,EAAK5B,aAAiC,SAAlB4B,EAAK7B,SAE9C,OACE,sBACEvC,UAAU,eADZ,WAIIwG,GACA,qBAAKxG,UAAS,QAAd,SACGN,KAAK+G,iBAAiBrC,EAAMA,EAAKjC,YAAY,KAElD,sBAAKnC,UAAU,OAAf,UACE,sBAAKA,UAAS,sBAA6C,IAA5BoE,EAAKlC,YAAYgD,OAAe,GAAK,yBAApE,UACGd,EAAKlC,YAAY0B,KAAI,SAAChB,EAAKwD,GAAN,OAAgB,EAAKM,WAAW9D,EAAKwD,MAC3D,wBACEnG,QAASP,KAAKsE,wBAAuB,EAAMI,EAAKjE,IAAI,SAACwG,GACnD,IAAIC,EAAgB,EAAKhF,gBAAgB+E,EAAWxG,IACpDwG,EAAWzE,YAAckC,EAAKlC,YAAYyB,OAAO,CAACiD,OAHtD,eAQCxC,EAAKpC,SAAW,wBACf/B,QAASP,KAAKsE,wBAAuB,EAAMI,EAAKpC,UAAU,SAAC6E,GACzDA,EAAa3E,YAAc2E,EAAa3E,YAAYiE,QAAO,SAACvD,GAC1D,OAAOA,EAAIzC,KAAOiE,EAAKjE,SAHZ,eAQP,QAEXqG,EACC,sBAAKxG,UAAU,gBAAf,UACE,qBACEA,UAAS,mCAA8BoE,EAAK7B,SAAnC,YAA+C6B,EAAK5B,YAAc,eAAiB,IAC5FvC,QAASP,KAAKsE,wBAAuB,EAAMI,EAAKjE,IAAI,SAACwG,GACnD,IAAMG,EAAa,CAAC,OAAQ,WAAY,SAAU,UAClDH,EAAWpE,SAAWuE,GAAYA,EAAWC,QAAQJ,EAAWpE,UAAY,GAAKuE,EAAW5B,QAChE,SAAxByB,EAAWpE,WACboE,EAAWnE,aAAemE,EAAWnE,kBAI3C,qBAAKxC,UAAS,oCAAd,SACGN,KAAK+G,iBAAiBrC,EAAMA,EAAK/B,eAAe,QAInD,qBACErC,UAAS,mCAA8BoE,EAAK7B,SAAnC,YAA+C6B,EAAK5B,YAAc,eAAiB,IAC5FvC,QAASP,KAAKsE,wBAAuB,EAAMI,EAAKjE,IAAI,SAACwG,GACnD,IAAMG,EAAa,CAAC,OAAQ,WAAY,SAAU,UAClDH,EAAWpE,SAAWuE,GAAYA,EAAWC,QAAQJ,EAAWpE,UAAY,GAAKuE,EAAW5B,QAChE,SAAxByB,EAAWpE,WACboE,EAAWnE,aAAemE,EAAWnE,kBAK/C,qBACExC,UAAU,aADZ,SAGGN,KAAK+G,iBAAiBrC,EAAMA,EAAK9B,iBAAiB,SAIpDkE,GACD,qBAAKxG,UAAS,YAAd,SACGN,KAAK+G,iBAAiBrC,EAAMA,EAAK/B,eAAe,OAhEhD+B,EAAKjE,M,yCAuEGiE,EAAM4C,EAAUC,GAAM,IAAD,OAChCT,EAAepC,EAAK5B,aAAiC,SAAlB4B,EAAK7B,SAE1C2E,EAAaD,EAAIE,OAAOH,IAAaR,EAAY,4BAErD,GAAIA,EAC+B,KAA7BpC,EAAK/B,cAAcrB,QACrBkG,GAAU,WAAQ9C,EAAK/B,cAAcrB,MAA3B,UAEP,CAKL,OAJIoD,EAAK5B,cACP0E,GAAc,YAGR9C,EAAK7B,UACX,IAAK,OACH2E,GAAc,WACd,MAEF,IAAK,WAAY,MACjB,QACEA,GAAU,WAAQ9C,EAAK7B,SAAb,KAKgB,KAA1B6B,EAAKjC,WAAWnB,QAClBkG,GAAU,cAAW9C,EAAKjC,WAAWnB,MAA3B,MAGqB,KAA7BoD,EAAK/B,cAAcrB,QACrBkG,GAAU,cAAW9C,EAAK/B,cAAcrB,MAA9B,MA8Bd,OA1BAkG,GAAc,KAEkB,IAA5B9C,EAAKlC,YAAYgD,QAGnBgC,GAAcD,EAAIE,OAAOH,GACzBE,GAAU,YAAS9C,EAAK9B,gBAAgBtB,MAA9B,UAKVoD,EAAKlC,YAAY0B,KAAI,SAACwD,GACpBF,GAAcD,EAAIE,OAAOH,GACzBE,GAAc,MAEdA,GAAU,UAAO,EAAKG,mBAAmBD,EAAgBJ,EAAW,EAAGC,IAEvEC,GAAcD,EAAIE,OAAOH,GACzBE,GAAc,SAIhBA,GAAcD,EAAIE,OAAOH,GACzBE,GAAU,YAAS9C,EAAK9B,gBAAgBtB,MAA9B,SAGLkG,I,+BAGC,IAAD,OACD5G,EAAWZ,KAAKgC,MAAMC,QAAQjC,KAAKgC,MAAMG,gBACzCyF,EAAe5H,KAAKwE,kBAAkB5D,GAAU,SAAA6D,GACpD,OAAOA,EAAGhE,KAAO,EAAKuB,MAAMI,kBAExBb,EAAWqG,EAAeA,EAAarG,SAAW,GAMxD,OAJAsG,QAAQC,IAAR,mBAAwBvG,EAAxB,yBAAiDqG,IAK/C,eAAC,IAAD,CACEtH,UAAU,cACVO,MAAO,CAAC,GAAI,IACZC,QAAS,IACTC,aAAa,EACbC,WAAY,GACZC,YAAY,SACZC,WAAY,GACZC,aAAc,EACdC,UAAU,aACVC,OAAO,aAVT,UAYE,cAACvB,EAAD,CACEc,SAAUZ,KAAKgH,WAAWpG,EAAU,IACpCW,SAAUA,EACVf,YAAa,WACX,EAAKuD,SAAS,CACZ3B,eAAgB,QAGpBlC,OAASF,KAAKgC,MAAMG,eAAiB,GAAO,WAC1C,EAAK4B,UAAS,SAAC/B,GAAD,MAAY,CACxBG,eAAgBH,EAAMG,eAAiB,OAG3C/B,OAASJ,KAAKgC,MAAMG,eAAkBnC,KAAKgC,MAAMC,QAAQuD,OAAS,GAAQ,WACxE,EAAKzB,UAAS,SAAC/B,GAAD,MAAY,CACxBG,eAAgBH,EAAMG,eAAiB,SAI7C,cAACR,EAAD,CAAYC,aAAc5B,KAAK2H,mBAAmB/G,EAAU,EAAG,iB,GA7W9Ca,IAAMC,WAmX/BqG,IAASC,OAAO,cAACnG,EAAD,IACdoG,SAASC,eAAe,U","file":"static/js/main.c48c9b98.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport PropTypes from 'prop-types';\nimport Split from 'react-split';\nimport { MathComponent } from 'mathjax-react';\nimport { v4 as uuidv4 } from 'uuid';\nimport clone from 'clone';\nimport deepEqual from 'deep-equal';\nimport './index.css';\n\nclass InputPane extends React.Component {\n  render() {\n    const undoDisabled = (this.props.onUndo === false);\n    const redoDisabled = (this.props.onRedo === false);\n\n    const inputPane = (\n      <div\n        className=\"input-pane pane\"\n        onClick={this.props.onViewClick}\n      >\n        <div id=\"history-buttons\">\n          <button\n            onClick={undoDisabled ? undefined : this.props.onUndo}\n            disabled={undoDisabled}\n          >Undo</button>\n          <button\n            onClick={redoDisabled ? undefined : this.props.onRedo}\n            disabled={redoDisabled}\n          >Redo</button>\n        </div>\n        <div className=\"tree-wrapper\">\n          {this.props.rootNode}\n        </div>\n      </div>\n    );\n\n    return (\n      <Split\n        className=\"left-pane\"\n        sizes={[80, 20]}\n        minSize={0}\n        expandToMin={false}\n        gutterSize={10}\n        gutterAlign=\"center\"\n        snapOffset={30}\n        dragInterval={1}\n        direction=\"vertical\"\n        cursor=\"row-resize\"\n      >\n        {inputPane}\n        <textarea\n          className=\"error-message-pane pane\"\n          value={this.props.errorMsg}\n          readOnly\n        />\n      </Split>\n    );\n  }\n}\n\nInputPane.propTypes = {\n  rootNode: PropTypes.object.isRequired,\n  errorMsg: PropTypes.string.isRequired,\n  onViewClick: PropTypes.func.isRequired,\n  onUndo: PropTypes.any.isRequired,\n  onRedo: PropTypes.any.isRequired,\n}\n\nclass OutputPane extends React.Component {\n  render() {\n    return (\n      <textarea\n        className=\"output-pane pane\"\n        value={this.props.outputSource}\n        readOnly\n      />\n    )\n  }\n}\n\nOutputPane.propTypes = {\n  outputSource: PropTypes.string.isRequired,\n}\n\nclass LiveEditor extends React.Component {\n  constructor(props) {\n    super(props);\n    this.currentLatexInputRef = React.createRef();\n    this.state = {\n      history: [this.createBlankNode()],\n      currentVersion: 0,\n      focusedInputId: null,\n      focusWasPerformed: false,\n    };\n  }\n\n  createBlankNode(parentId) {\n    return {\n      parentId: parentId,\n      id: uuidv4(),\n\n      assumptions: [],\n      labelInput: this.createBlankLatexInput(),\n      ruleNameInput: this.createBlankLatexInput(),\n      conclusionInput: this.createBlankLatexInput(),\n\n      lineType: 'straight',\n      lineDoubled: false\n    };\n  }\n\n  createBlankLatexInput(initialValue = '') {\n    return {\n      id: uuidv4(),\n      value: initialValue,\n      errorMsg: ''\n    };\n  }\n\n  findNodeRec(currentNode, pred) {\n    if (pred(currentNode)) {\n      return currentNode;\n    } else {\n      for (const ass of currentNode.assumptions) {\n        const result = this.findNodeRec(ass, pred);\n        if (result !== undefined) {\n          return result;\n        }\n      }\n    }\n  }\n\n  findLatexInputRec(rootNode, pred) {\n    const candidateNode = this.findNodeRec(rootNode, (currNode) => {\n      return [\n        currNode.labelInput, \n        currNode.ruleNameInput, \n        currNode.conclusionInput\n      ].findIndex(pred) !== -1;\n    });\n\n    if (candidateNode === undefined)\n      return;\n\n    return [\n      candidateNode.labelInput, \n      candidateNode.ruleNameInput, \n      candidateNode.conclusionInput\n    ].find(pred); \n  }\n\n  updateNodeStateOnEvent(save, nodeId, func) {\n    return (event) => {\n      const rootNodeNewVersion = clone(this.state.history[this.state.currentVersion]);\n\n      func(\n        this.findNodeRec(rootNodeNewVersion, currNode => currNode.id === nodeId),\n        event);\n\n      this.setState((state) => ({\n        history: save ?\n          state.history.slice(0, state.currentVersion + 1).concat([rootNodeNewVersion]) :\n          state.history.map((version, versionIndex) => {\n            if (versionIndex === state.currentVersion) {\n              return rootNodeNewVersion;\n            } else {\n              return version;\n            }\n          }),\n        currentVersion: save ?\n          state.currentVersion + 1 :\n          state.currentVersion\n      })\n      );\n    };\n  }\n\n  updateLatexInputStateOnEvent(save, nodeId, latexInputId, func) {\n    return this.updateNodeStateOnEvent(save, nodeId, (newNodeVersion, event) => {\n      func(this.findLatexInputRec(newNodeVersion, li => li.id === latexInputId), event);\n    });\n  }\n\n  renderLatexInput(node, latexInput, smallTextModeEnabled = true) {\n    const dots = smallTextModeEnabled ? '□' : '□';\n    const focused = this.state.focusedInputId && latexInput.id == this.state.focusedInputId;\n    const latexHidden = focused || latexInput.errorMsg !== '';\n    const justFocused = focused && (!this.state.focusWasPerformed);\n\n    return (\n      <div\n        className='latex-input-wrapper'\n        onClick={(event) => {\n          event.stopPropagation();\n        }}\n      >\n        <div\n          className='latex-input-output'\n          tabIndex={0}\n          onFocus={(_) => {\n            this.setState({\n              focusedInputId: latexInput.id,\n              focusWasPerformed: false,\n            });\n          }}\n          hidden={latexHidden}\n        >\n          <MathComponent\n            display={false}\n            tex={smallTextModeEnabled ?\n              `\\\\small{\\\\text{${latexInput.value.length === 0 ? dots : latexInput.value}}}` :\n              `${latexInput.value.length === 0 ? dots : latexInput.value}`\n            }\n            onError={this.updateLatexInputStateOnEvent(false, node.id, latexInput.id, (newLIVer, errorMsg) => {\n              debugger;\n              newLIVer.errorMsg = errorMsg;\n            })}\n            onSuccess={this.updateLatexInputStateOnEvent(false, node.id, latexInput.id, (newLIVer, _) => {\n              newLIVer.errorMsg = '';\n            })}\n          />\n        </div>\n        {latexHidden && <div className='latex-input-input'>\n          <input\n            className={latexInput.errorMsg === '' ? '' : 'invalid-latex-input'}\n            type='text'\n            placeholder={dots}\n            defaultValue={latexInput.value}\n            style={{ width: `${Math.max(dots.length, latexInput.value.length)}ch` }}\n            onInput={this.updateLatexInputStateOnEvent(false, node.id, latexInput.id, (newLIVer, event) => {\n              newLIVer.value = event.target.value;\n            })}\n            ref={focused ? this.currentLatexInputRef : null}\n            onFocus={this.updateLatexInputStateOnEvent(justFocused, node.id, latexInput.id, (newLIVer, event) => {\n              this.setState({\n                focusedInputId: latexInput.id,\n              });\n            })}\n            onBlur={(event) => {\n              if (deepEqual(\n                this.state.history[this.state.currentVersion],\n                this.state.history[this.state.currentVersion - 1]\n              )) {\n                this.setState((state) => ({\n                  history: state.history.filter((_, index) => (index !== state.currentVersion)),\n                  currentVersion: state.currentVersion - 1\n                }));\n              }\n            }}\n          />\n        </div>}\n      </div>\n    );\n  }\n\n  componentDidUpdate() {\n    if (this.currentLatexInputRef.current && !this.state.focusWasPerformed) {\n      this.currentLatexInputRef.current.focus();\n      this.currentLatexInputRef.current.setSelectionRange(0, this.currentLatexInputRef.current.value.length);\n      this.setState({\n        focusWasPerformed: true\n      });\n    }\n  }\n\n  renderNode(node) {\n    const proofSummary = node.lineDoubled && node.lineType === 'none';\n\n    return (\n      <div\n        className='node-wrapper'\n        key={node.id}\n      >\n        {!proofSummary &&\n          <div className={`label`}>\n            {this.renderLatexInput(node, node.labelInput, true)}\n          </div>}\n        <div className='node'>\n          <div className={`assumptions ${node.assumptions.length === 0 ? '' : 'not-empty-assumptions'}`}>\n            {node.assumptions.map((ass, index) => this.renderNode(ass, index))}\n            <button\n              onClick={this.updateNodeStateOnEvent(true, node.id, (newNodeVer) => {\n                let newAssumption = this.createBlankNode(newNodeVer.id);\n                newNodeVer.assumptions = node.assumptions.concat([newAssumption]);\n              })}\n            >\n              +\n            </button>\n            {node.parentId ? <button\n              onClick={this.updateNodeStateOnEvent(true, node.parentId, (newParentVer) => {\n                newParentVer.assumptions = newParentVer.assumptions.filter((ass) => {\n                  return ass.id !== node.id;\n                });\n              })}\n            >\n              -\n          </button> : null}\n          </div >\n          {proofSummary ? (\n            <div className='proof-summary'>\n              <div\n                className={`inference-line line-type-${node.lineType} ${node.lineDoubled ? 'line-doubled' : ''}`}\n                onClick={this.updateNodeStateOnEvent(true, node.id, (newNodeVer) => {\n                  const LINE_TYPES = ['none', 'straight', 'dotted', 'dashed'];\n                  newNodeVer.lineType = LINE_TYPES[(LINE_TYPES.indexOf(newNodeVer.lineType) + 1) % LINE_TYPES.length];\n                  if (newNodeVer.lineType === 'none') {\n                    newNodeVer.lineDoubled = !newNodeVer.lineDoubled;\n                  }\n                })}\n              />\n              <div className={`proof-summary-rule-name rule-name`}>\n                {this.renderLatexInput(node, node.ruleNameInput, true)}\n              </div>\n            </div>\n          ) : (\n              <div\n                className={`inference-line line-type-${node.lineType} ${node.lineDoubled ? 'line-doubled' : ''}`}\n                onClick={this.updateNodeStateOnEvent(true, node.id, (newNodeVer) => {\n                  const LINE_TYPES = ['none', 'straight', 'dotted', 'dashed'];\n                  newNodeVer.lineType = LINE_TYPES[(LINE_TYPES.indexOf(newNodeVer.lineType) + 1) % LINE_TYPES.length];\n                  if (newNodeVer.lineType === 'none') {\n                    newNodeVer.lineDoubled = !newNodeVer.lineDoubled;\n                  }\n                })}\n              />\n            )}\n          <div\n            className='conclusion'\n          >\n            {this.renderLatexInput(node, node.conclusionInput, false)}\n          </div>\n        </div>\n        {\n          !proofSummary &&\n          <div className={`rule-name`}>\n            {this.renderLatexInput(node, node.ruleNameInput, true)}\n          </div>\n        }\n      </div >\n    );\n  }\n\n  generateNodeSource(node, tablevel, tab) {\n    const proofSummary = node.lineDoubled && node.lineType === 'none';\n\n    let nodeSource = tab.repeat(tablevel) + (proofSummary ? `\\\\prfsummary` : `\\\\prftree`);\n\n    if (proofSummary) {\n      if (node.ruleNameInput.value !== '') {\n        nodeSource += `[${node.ruleNameInput.value}]`;\n      }\n    } else {\n      if (node.lineDoubled) {\n        nodeSource += '[double]';\n      }\n\n      switch (node.lineType) {\n        case 'none': {\n          nodeSource += '[noline]';\n          break;\n        }\n        case 'straight': break;\n        default: {\n          nodeSource += `[${node.lineType}]`;\n          break;\n        }\n      }\n\n      if (node.labelInput.value !== '') {\n        nodeSource += `[l]{${node.labelInput.value}}`;\n      }\n\n      if (node.ruleNameInput.value !== '') {\n        nodeSource += `[r]{${node.ruleNameInput.value}}`;\n      }\n    }\n\n    nodeSource += '\\n';\n\n    if (node.assumptions.length === 0) {\n\n      // add conclusion\n      nodeSource += tab.repeat(tablevel);\n      nodeSource += `{ ${node.conclusionInput.value} }\\n`;\n\n    } else {\n\n      // add assumptions\n      node.assumptions.map((assumptionNode) => {\n        nodeSource += tab.repeat(tablevel);\n        nodeSource += '{\\n';\n\n        nodeSource += `${this.generateNodeSource(assumptionNode, tablevel + 1, tab)}`;\n\n        nodeSource += tab.repeat(tablevel);\n        nodeSource += '}\\n';\n      });\n\n      // add conclusion\n      nodeSource += tab.repeat(tablevel);\n      nodeSource += `{ ${node.conclusionInput.value} }\\n`;\n    }\n\n    return nodeSource;\n  }\n\n  render() {\n    const rootNode = this.state.history[this.state.currentVersion];\n    const focusedInput = this.findLatexInputRec(rootNode, li => {\n      return li.id === this.state.focusedInputId;\n    });\n    const errorMsg = focusedInput ? focusedInput.errorMsg : '';\n\n    console.log(`errorMsg ${errorMsg} focusedInput ${focusedInput}`);\n\n    if (rootNode === undefined) debugger;\n\n    return (\n      <Split\n        className=\"live-editor\"\n        sizes={[50, 50]}\n        minSize={100}\n        expandToMin={false}\n        gutterSize={10}\n        gutterAlign=\"center\"\n        snapOffset={30}\n        dragInterval={1}\n        direction=\"horizontal\"\n        cursor=\"col-resize\"\n      >\n        <InputPane\n          rootNode={this.renderNode(rootNode, [])}\n          errorMsg={errorMsg}\n          onViewClick={() => {\n            this.setState({\n              focusedInputId: null\n            });\n          }}\n          onUndo={(this.state.currentVersion > 0) && (() => {\n            this.setState((state) => ({\n              currentVersion: state.currentVersion - 1\n            }));\n          })}\n          onRedo={(this.state.currentVersion < (this.state.history.length - 1)) && (() => {\n            this.setState((state) => ({\n              currentVersion: state.currentVersion + 1\n            }));\n          })}\n        />\n        <OutputPane outputSource={this.generateNodeSource(rootNode, 0, '    ')} />\n      </Split>\n    )\n  }\n}\n\nReactDOM.render(<LiveEditor />,\n  document.getElementById('root'));\n"],"sourceRoot":""}